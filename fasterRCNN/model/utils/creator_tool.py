import numpy as np 
import cupy as cp 

from model.utils.bbox_tools import loc2bbox
from model.utils.nms import non_maximum_suppression

class ProposalCreator:
	''' Proposal regions are generated by calling this object in the precess of rpn.

	the method `__call__` of this object outputs object detection proposals 
	by applying estimated bounding box offsets to a set of anchors.

	This class takes parameters to control number of bounding boxes to
	pass to NMS and keep after NMS.

	If the parameters are negative, it uses all the bounding boxes supplied
	or keep all the bounding boxes returned by NMS.

	Args:
		nms_thresh(float): Threshold value used when calling NMS.
		n_train_pre_nms(int): Number of top scored bounding boxes to keep after passing to NMS in train mode.
		n_train_post_nms(int): Number of top scored bounding boxes to keep after passing to NMS in train mode.
		n_test_pre_nms(int): Number of top scored bounding boxes to keep before passing to NMS in test mode.
		n_test_post_nms(int): Number of top scored bounding boxes to keep after passing to NMS in test mode.
		force_cpu_nms(bool): If this is True,always use NMS in CPU mode.If it is False,the NMS mode is selected based on the type of inputs.
		min_size(int): A parameter to determine the threshold on discarding bounding boxes based on their sizes

	'''

	def __init__(self, 
				parent_model,
				nms_thresh=0.7,
				n_train_pre_nms=12000,
				n_train_post_nms=2000,
				n_test_pre_nms=6000,
				n_test_post_nms=300,
				min_size=16):
		self.parent_model = parent_model
		self.nms_thresh = nms_thresh
		self.n_train_pre_nms = n_train_pre_nms
		self.n_train_post_nms = n_train_post_nms
		self.n_test_pre_nms = n_test_pre_nms
		self.n_test_post_nms = n_test_post_nms
		self.min_size = min_size

	def __call__(self, loc, score, anchor, img_size, scale=1.):
		'''
		input should be ndarray
		Proposal RoIs.

		Inputs: `loc, score, anchor ` refer to the same anchor when indexed by the same index.

		`R` is the total number of anchors.This is equal to product of the height and the width
		of an image the number of anchor bases per pixel.

		Type of the output is same as inputs.

		Args:
			loc(array): Predicted offsets and scaling to anchors.
				Its shape is `(R, 4)`
			score(array): Predicted foreground probability for anchors.
				Its shape is `(R,)`
			anchor(array): Coordinates of anchorsx.Its shape is `(R, 4)`
			img_size(tuple of ints): `(height, width)`,which contains image after scaling.
			scale(float): The scaling factor used to scale an image after reading it from a file.


		Returns:
			array:
			An array of coordinates of proposal boxes.
			Its shape if `(S, 4)`,while `S` is less than `self.n_test_post_nms` in test time
			and less than `self.n_train_post_nms` in train time.
			`S` depends on the size of the predicted bounding boxes and the number of
			bounding boxes discarded by NMS.

		'''

		if self.parent_model.training
			n_pre_nms = self.n_train_pre_nms
			n_post_nms = self.n_train_post_nms

		else:
			n_pre_nms = self.n_test_pre_nms
			n_post_nms = self.n_test_post_nms


		roi = loc2bbox(anchor, loc)

		#do the truncation, lower limit:0, upper limit: img_size 
		roi[:, [0,2]] = np.clip(roi[:, [0,2]], 0, img_size[0])   # y coordinates
		roi[:, [1,3]] = np.clip(roi[:, [1,3]], 0, img_size[1])	 # x coordinates

		#Remove predicted boxes with either height or width less than threshold.
		#while threshold is the product of a preset value :self.min_size(16 in default)
		#and the value `scale`(the scaling size compared to the original image)
		
		min_size = self.min_size * scale
		hs = roi[:, 2] - roi[:, 0]   # y_{max} - y_{min}
		ws = roi[:, 3] - roi[:, 1]   # x_{max} - x_{min}

		keep = np.where((hs>=min_size)&(ws>=min_size))[0]
		roi = roi[keep, :]
		score = score[keep]

		# sort all proposal-score pairs by score from highest to lowest.
		# and keep top pre_nms_topN(6000 in default)

		order = score.argsort()[::-1]
		order = order[:n_pre_nms]
		roi = roi[order,:]

		# Apply nms(eg. threshold = 0.7)
		# Take after_nms_topN(eg. 300)

		keep = non_maximum_suppression(
			cp.ascontiguousarray(cp.asarray(roi)),
			thresh=self.nms_thresh)

		keep = keep[:,n_post_nms]
		roi = roi[keep]

		return roi


